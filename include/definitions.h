//
// Created by alex on 30/09/16.
//

#ifndef METADIFF_CORE_DEFINITIONS_H
#define METADIFF_CORE_DEFINITIONS_H
namespace md{
    namespace core{
        /**
         * A NodeGroup is an abstraction of grouping together nodes into hiearchies
         * How they are grouped is fully determinate by the user.
         * The hierarchy of groups is necessarily a DAG as well starting with a single root group.
         * The main goal of the groups is to provide a better way of visualizing the computation,
         * as well as a block for naming parameters accordingly.
         */
        class NodeGroup {
        public:
            /** The name of this group */
            std::string const name;
            /** This is the full name of the group, which depends on the parent */
            std::string full_name;
            /** The parent NodeGroup */
            std::weak_ptr<NodeGroup> const parent;
            /** The children groups */
            std::vector<std::weak_ptr<NodeGroup>> children;

            NodeGroup() :
                    name(utils::props()->group_root),
                    full_name(utils::props()->group_root) { };

            NodeGroup(const std::string name,
                      const std::weak_ptr<NodeGroup> parent) :
                    name(name),
                    parent(parent) {
                if (parent.lock()->full_name == utils::props()->group_root) {
                    full_name = name;
                } else {
                    full_name = parent.lock()->full_name;
                    full_name += utils::props()->group_delimiter;
                    full_name += name;
                }
            };
        };

        /** A symbolic integer is a Polynomial */
        typedef sym::Polynomial SymInt;
        /** All shapes are represented as symbolic integers */
        typedef std::array<SymInt, 4> Shape;
        /** For Operators which require Axes arguments */
        typedef std::vector<short> Axes;
        namespace op {
            /** Forward declaration */
            class AbstractOperator;
        }
        /** Forward declaration */
        class GraphInternal;
        /** Forward declaration */
        class NodeInternal;
        /** Forward declaration */
        class Node;
        /** Forward declaration */
        class NodeData;
        /** Operator is just a shared_ptr to AbstractOperator */
        typedef std::shared_ptr<op::AbstractOperator> Operator;
        /** Group is a weak_ptr as it is owned by the graph */
        typedef std::weak_ptr<core::NodeGroup> Group;
        /** Vector of Nodes */
        typedef std::vector<Node> NodeVec;
        /** An update is a pair of shared variable and a node */
        typedef std::pair<Node, Node> Update;
        /** A collection of updates */
        typedef std::vector<std::pair<Node, Node>> Updates;
        /** Just a pointer to GraphInternal */
        typedef GraphInternal* GraphInPtr;
        /** A shared_ptr to GraphInternal, this is the outside API */
        typedef std::shared_ptr<core::GraphInternal> Graph;


        /**
         * The class provides data generated by the graph optimizer relevant to the backends
         * TODO This is not yet complete, high probability it will expand in the future
         */
        class ExecutionData {
        public:
            /**
             * Whether the node should be computed in place
             * This is possible only when some of the operands lifespan expires
             * TOOD At this stage is unclear whether we need this if we do register allocation
             */
            bool inplace;
            /** The graph optimizer allocated register id*/
            size_t register_id;
            /**
             * For synchronization and memory allocation this will contain the time step after
             * which the node can be destroyed
             */
            size_t lifespan;

            ExecutionData() :
                    inplace(false),
                    register_id(0),
                    lifespan(0) { };

            ExecutionData(ExecutionData const &data) :
                    inplace(data.inplace),
                    register_id(data.register_id),
                    lifespan(data.lifespan) { };
        };

//        /**
//         * Evaluators would be constructed by the backend and will allow for on the fly non-optimized
//         * computation (imperative)
//         */
//        template <typename T>
//        class Evaluator{
//        public:
//            T eval(Node node, std::vector<std::pair<Node, T>> provided);
//
//            T eval(Node node){
//                return eval(node, {});
//            }
//        };

        /**
         * A single computational device to facilitate multy node computations
         * TODO not yet well designed, high probability it will change in the future
         */
        class Device {
        public:
            /** Type of the device - host or gpu*/
            deviceType type;
            /** A unique identifier of the device */
            size_t id;

            Device(const deviceType type, const size_t id) :
                    type(type),
                    id(id) { };

            Device(const Device &device) :
                    type(device.type),
                    id(device.id) { };

        };

        inline bool operator==(const Device& device1, const Device& device2){
            return device1.type == device2.type and device1.id == device2.id;
        }

        inline bool operator!=(const Device& device1, const Device& device2){
            return device1.type != device2.type or device1.id != device2.id;
        }

        inline Device host(){
            static Device host(deviceType::CPU, 0);
            return host;
        }
    }
}
#endif //METADIFF_CORE_DEFINITIONS_H
