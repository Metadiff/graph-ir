//
// Created by alex on 30/09/16.
//

#ifndef METADIFF_CORE_DEFINITIONS_H
#define METADIFF_CORE_DEFINITIONS_H
namespace md{
    namespace core{
        /** A collection of all the policies we have on the graph */
        class GraphPolicies{
        public:
            /** Error policy for implicit broadcasts */
            Policy implicit_broadcast;
            /** Error policy for type promotions */
            Policy data_type_promotion;
            /** Error policy for implicit cast */
            Policy cast;
            /** Error policy for requesting gradient with respect to something it does not depend on */
            Policy non_dependable_gradient;

            GraphPolicies(Policy const implicit_broadcast,
                          Policy const data_type_promotion,
                          Policy const cast,
                          Policy const non_dependable_gradient):
                    implicit_broadcast(implicit_broadcast),
                    data_type_promotion(data_type_promotion),
                    cast(cast),
                    non_dependable_gradient(non_dependable_gradient){};

            GraphPolicies(GraphPolicies const & policies):
                    implicit_broadcast(policies.implicit_broadcast),
                    data_type_promotion(policies.data_type_promotion),
                    cast(policies.cast),
                    non_dependable_gradient(policies.non_dependable_gradient){};

        };

        /**
         * A single computational device to facilitate multy node computations
         * TODO not yet well designed, high probability it will change in the future
         */
        class Device {
        public:
            /** Type of the device - host or gpu*/
            DeviceType type;
            /** A unique identifier of the device */
            size_t id;

            Device(const DeviceType type, const size_t id) :
                    type(type),
                    id(id) { };

            Device(const std::shared_ptr<Device> ptr) :
                    type(ptr->type),
                    id(ptr->type) { };

            Device(Device const & device) :
                    type(device.type),
                    id(device.id) { };

        };

        bool operator==(Device const & device1, Device const & device2);

        bool operator!=(Device const & device1, Device const & device2);

        inline std::shared_ptr<Device> host(){
            static std::shared_ptr<Device> host;
            if(not host){
                host = std::make_shared<Device>(DeviceType::CPU, 0);
            }
            return host;
        };

        /**
        * The class provides data generated by the graph optimizer relevant to the backends
        * TODO This is not yet complete, high probability it will expand in the future
        */
        class ExecutionData {
        public:
            /**
             * Whether the node should be computed in place
             * This is possible only when some of the operands lifespan expires
             * TOOD At this stage is unclear whether we need this if we do register allocation
             */
            bool inplace;
            /** The graph optimizer allocated register id*/
            size_t register_id;
            /**
             * For synchronization and memory allocation this will contain the time step after
             * which the node can be destroyed
             */
            size_t lifespan;

            ExecutionData() :
                    inplace(false),
                    register_id(0),
                    lifespan(0) { };

            ExecutionData(ExecutionData const &data) :
                    inplace(data.inplace),
                    register_id(data.register_id),
                    lifespan(data.lifespan) { };
        };

        /** Forward declaration */
        class GraphInternal;
        /** Just a pointer to GraphInternal */
        typedef GraphInternal* GraphInPtr;

        /**
         * A NodeGroup is an abstraction which allows the user to group different nodes together.
         * This is intended for purely vizualization reasons.
         */
        class NodeGroup {
        public:
            /** The name of this group */
            std::string const name;
            /** The owning graph */
            GraphInPtr const graph;
            /** The parent NodeGroup */
            std::weak_ptr<NodeGroup> const parent;
            /** This is the full name of the group, which depends on the parent */
            std::string full_name;
            /** The children groups */
            std::vector<std::weak_ptr<NodeGroup>> children;

            NodeGroup(const std::string name,
                      const std::weak_ptr<NodeGroup> parent);

            NodeGroup(const std::string name,
                      const GraphInPtr graph);

            bool is_base() const;

        };

        /** A symbolic integer is a Polynomial */
        typedef sym::Polynomial SymInt;
        /** All shapes are represented as symbolic integers */
        typedef std::array<SymInt, 4> Shape;
        /** For Operators which require Axes arguments */
        typedef std::vector<int> Axes;
        namespace op {
            /** Forward declaration */
            class AbstractOperator;
        }
        /** Forward declaration */
        class NodeInternal;
        /** Forward declaration */
        class Node;
        /** Forward declaration */
        class NodeData;
        /** Operator is just a shared_ptr to AbstractOperator */
        typedef std::shared_ptr<op::AbstractOperator> Operator;
        /** Group is a weak_ptr as it is owned by the graph */
        typedef std::weak_ptr<core::NodeGroup> Group;
        /** Vector of Nodes */
        typedef std::vector<Node> NodeVec;
        /** An update is a pair of shared variable and a node */
        typedef std::pair<Node, Node> Update;
        /** A collection of updates */
        typedef std::vector<std::pair<Node, Node>> Updates;
        /** A shared_ptr to GraphInternal, this is the outside API */
        typedef std::shared_ptr<core::GraphInternal> Graph;
    }
}
#endif //METADIFF_CORE_DEFINITIONS_H
